From ec563704ab5ef48bf308924de4ef021c4d0cd2af Mon Sep 17 00:00:00 2001
From: DJ Delorie <dj@delorie.com>
Date: Sat, 13 Feb 2021 00:30:36 -0500
Subject: [PATCH] Add Intel CET support

Adds two features:

1. Parsing CET-enabled PLTs.
2. Using a second "insecure" PLT as a fallback.

This is downstream Fedora patch: ltrace-0.7.91-cet.patch
The downstream patch can be removed.

Signed-off-by: DJ Delorie <dj@redhat.com>
=========================================
I enabled ARCH_HAVE_LTELF_DATA for x86 in order to include the code from the patch. It was originally enabled in this commit https://gitlab.com/cespedes/ltrace/-/commit/7b0088dbf6861987f13ad1e0740d633069fdb9d7.
There has been several changes to arch_elf_init (plt.c) since this^ commit.

Origin: upstream, https://gitlab.com/cespedes/ltrace/-/commit/ec563704ab5ef48bf308924de4ef021c4d0cd2af
Co-Authored-By: Ravi Kant Sharma <ravi.kant.sharma@canonical.com>
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/ltrace/+bug/1992939
Last-Update: 2023-12-13

---
 debug.h                      |   1 +
 ltrace-elf.c                 |  16 +++-
 ltrace-elf.h                 |   1 +
 sysdeps/linux-gnu/x86/arch.h |  15 +++-
 sysdeps/linux-gnu/x86/plt.c  | 162 ++++++++++++++++++++++++++++++++++-
 5 files changed, 191 insertions(+), 4 deletions(-)

diff --git a/debug.h b/debug.h
index 4775d2f..e06fdf3 100644
--- a/debug.h
+++ b/debug.h
@@ -20,6 +20,7 @@
 
 #ifndef _DEBUG_H
 #define _DEBUG_H
+#include "backend.h"
 
 /* debug levels:
  */
diff --git a/ltrace-elf.c b/ltrace-elf.c
index fadd3c1..6eada15 100644
--- a/ltrace-elf.c
+++ b/ltrace-elf.c
@@ -632,7 +632,21 @@ ltelf_read_elf(struct ltelf *lte, const char *filename)
 			}
 		} else if (shdr.sh_type == SHT_PROGBITS
 			   || shdr.sh_type == SHT_NOBITS) {
-			if (strcmp(name, ".plt") == 0) {
+			if (strcmp(name, ".plt") == 0
+			    && lte->second_plt_seen == 0) {
+				lte->plt_addr = shdr.sh_addr;
+				lte->plt_size = shdr.sh_size;
+				lte->plt_data = elf_loaddata(scn, &shdr);
+				if (lte->plt_data == NULL)
+					fprintf(stderr,
+						"Can't load .plt data\n");
+				lte->plt_flags = shdr.sh_flags;
+			}
+			/* An Intel CET binary has two PLTs; the
+			   initial PLTGOT points to the second
+			   one.  */
+			else if (strcmp(name, ".plt.sec") == 0) {
+				lte->second_plt_seen = 1;
 				lte->plt_addr = shdr.sh_addr;
 				lte->plt_size = shdr.sh_size;
 				lte->plt_data = elf_loaddata(scn, &shdr);
diff --git a/ltrace-elf.h b/ltrace-elf.h
index 42c2e05..2e00793 100644
--- a/ltrace-elf.h
+++ b/ltrace-elf.h
@@ -47,6 +47,7 @@ struct ltelf {
 	Elf_Data *dynsym;
 	size_t dynsym_count;
 	const char *dynstr;
+	int second_plt_seen;
 	GElf_Addr plt_addr;
 	GElf_Word plt_flags;
 	size_t plt_size;
diff --git a/sysdeps/linux-gnu/x86/arch.h b/sysdeps/linux-gnu/x86/arch.h
index 329cfba..440020e 100644
--- a/sysdeps/linux-gnu/x86/arch.h
+++ b/sysdeps/linux-gnu/x86/arch.h
@@ -1,6 +1,6 @@
 /*
  * This file is part of ltrace.
- * Copyright (C) 2011, 2012 Petr Machata
+ * Copyright (C) 2011,2012,2013 Petr Machata, Red Hat Inc.
  * Copyright (C) 2006 Ian Wienand
  * Copyright (C) 2004 Juan Cespedes
  *
@@ -19,6 +19,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+#ifndef LTRACE_X86_ARCH_H
+#define LTRACE_X86_ARCH_H
+
+#include "vect.h"
 
 #define BREAKPOINT_VALUE {0xcc}
 #define BREAKPOINT_LENGTH 1
@@ -28,9 +32,18 @@
 #define ARCH_HAVE_ALIGNOF
 #define ARCH_ENDIAN_LITTLE
 
+#define ARCH_HAVE_ADD_PLT_ENTRY
+
+#define ARCH_HAVE_LTELF_DATA
+struct arch_ltelf_data {
+	struct vect plt_map;
+};
+
 #ifdef __x86_64__
 #define LT_ELFCLASS	ELFCLASS64
 #define LT_ELF_MACHINE	EM_X86_64
 #endif
 #define LT_ELFCLASS2	ELFCLASS32
 #define LT_ELF_MACHINE2	EM_386
+
+#endif /* LTRACE_X86_ARCH_H */
diff --git a/sysdeps/linux-gnu/x86/plt.c b/sysdeps/linux-gnu/x86/plt.c
index dc6f183..d885ab8 100644
--- a/sysdeps/linux-gnu/x86/plt.c
+++ b/sysdeps/linux-gnu/x86/plt.c
@@ -19,16 +19,174 @@
  */
 
 #include <gelf.h>
+#include <stdbool.h>
+
 #include "proc.h"
 #include "common.h"
 #include "library.h"
+#include "trace.h"
+
+static GElf_Addr
+x86_plt_offset(struct ltelf *lte, uint32_t i)
+{
+	/* Skip the first PLT entry, which contains a stub to call the
+	 * resolver.  */
+	return (i + (lte->second_plt_seen ? 0 : 1)) * 16;
+}
 
 GElf_Addr
-arch_plt_sym_val(struct ltelf *lte, size_t ndx, GElf_Rela * rela) {
-	return lte->plt_addr + (ndx + 1) * 16;
+arch_plt_sym_val(struct ltelf *lte, size_t ndx, GElf_Rela *rela)
+{
+	uint32_t i = *VECT_ELEMENT(&lte->arch.plt_map, uint32_t, ndx);
+	return x86_plt_offset(lte, i) + lte->plt_addr;
 }
 
 void *
 sym2addr(Process *proc, struct library_symbol *sym) {
 	return sym->enter_addr;
 }
+
+enum plt_status
+arch_elf_add_plt_entry(Process *proc, struct ltelf *lte,
+		       const char *a_name, GElf_Rela *rela, size_t ndx,
+		       struct library_symbol **ret)
+{
+	bool irelative = false;
+	if (lte->ehdr.e_machine == EM_X86_64) {
+#ifdef R_X86_64_IRELATIVE
+		irelative = GELF_R_TYPE(rela->r_info) == R_X86_64_IRELATIVE;
+#endif
+	} else {
+		assert(lte->ehdr.e_machine == EM_386);
+#ifdef R_386_IRELATIVE
+		irelative = GELF_R_TYPE(rela->r_info) == R_386_IRELATIVE;
+#endif
+	}
+
+	if (irelative)
+		return linux_elf_add_plt_entry_irelative(proc, lte, rela,
+							 ndx, ret);
+
+	return plt_default;
+}
+
+int
+arch_elf_init(struct ltelf *lte, struct library *lib)
+{
+	VECT_INIT(&lte->arch.plt_map, unsigned int);
+
+	if (vect_reserve(&lte->arch.plt_map, vect_size(&lte->plt_relocs)) < 0) {
+		arch_elf_destroy(lte);
+		return -1;
+	}
+
+	{
+		unsigned int i, sz = vect_size(&lte->plt_relocs);
+		for (i = 0; i < sz; ++i)
+			vect_pushback (&lte->arch.plt_map, &i);
+	}
+
+	/* IRELATIVE slots may make the whole situation a fair deal
+	 * more complex.  On x86{,_64}, the PLT slots are not
+	 * presented in the order of the corresponding relocations,
+	 * but in the order it which these symbols are in the symbol
+	 * table.  That's static symbol table, which may be stripped
+	 * off, not dynsym--that doesn't contain IFUNC symbols at all.
+	 * So we have to decode each PLT entry to figure out what
+	 * entry it corresponds to.  We need to interpret the PLT
+	 * table to figure this out.
+	 *
+	 * On i386, the PLT entry format is as follows:
+	 *
+	 *	8048300:   ff 25 0c a0 04 08       jmp    *0x804a00c
+	 *	8048306:   68 20 00 00 00          push   $0x20
+	 *	804830b:   e9 e0 ff ff ff          jmp    80482f0 <_init+0x30>
+	 *
+	 * For PIE binaries it is the following:
+	 *
+	 *	    410:   ff a3 10 00 00 00       jmp    *0x10(%ebx)
+	 *	    416:   68 00 00 00 00          push   $0x0
+	 *	    41b:   e9 d0 ff ff ff          jmp    3f0 <_init+0x30>
+	 *
+	 * On x86_64, it is:
+	 *
+	 *	 400420:   ff 25 f2 0b 20 00       jmpq   *0x200bf2(%rip)        # 601018 <_GLOBAL_OFFSET_TABLE_+0x18>
+	 *	 400426:   68 00 00 00 00          pushq  $0x0
+	 *	 40042b:   e9 e0 ff ff ff          jmpq   400410 <_init+0x18>
+	 *
+	 * For CET binaries it is the following:
+	 *
+	 *	13d0:       f3 0f 1e fa             endbr64
+	 *	13d4:       68 27 00 00 00          pushq  $0x27  <-- index
+	 *	13d9:       f2 e9 71 fd ff ff       bnd jmpq 1150 <.plt>
+	 *	13df:       90                      nop
+	 *
+         * On i386, the argument to push is an offset of relocation to
+	 * use.  The first PLT slot has an offset of 0x0, the second
+	 * 0x8, etc.  On x86_64, it's directly the index that we are
+	 * looking for.
+	 */
+
+	/* Here we scan the PLT table and initialize a map of
+	 * relocation->slot number in lte->arch.plt_map.  */
+
+	unsigned int i, sz = vect_size(&lte->plt_relocs);
+	for (i = 0; i < sz; ++i) {
+
+		GElf_Addr offset = x86_plt_offset(lte, i);
+		uint32_t reloc_arg;
+
+		uint8_t byte;
+		if (elf_read_next_u8(lte->plt_data, &offset, &byte) < 0)
+		  continue;
+
+
+		if (byte == 0xf3
+		    && elf_read_next_u8(lte->plt_data, &offset, &byte) >= 0
+		    && byte == 0x0f
+		    && elf_read_next_u8(lte->plt_data, &offset, &byte) >= 0
+		    && byte == 0x1e
+		    && elf_read_next_u8(lte->plt_data, &offset, &byte) >= 0
+		    && byte == 0xfa
+		    && elf_read_next_u8(lte->plt_data, &offset, &byte) >= 0
+		    && byte == 0x68
+		    && elf_read_next_u32(lte->plt_data,
+					 &offset, &reloc_arg) >= 0)
+		  {
+		    /* CET */
+		    fprintf(stderr, "%d: reloc_arg is %lx\n", i, (long)reloc_arg);
+		    *VECT_ELEMENT(&lte->arch.plt_map, unsigned int, reloc_arg) = i;
+		    continue;
+		  }
+
+		if (byte != 0xff
+		    || elf_read_next_u8(lte->plt_data, &offset, &byte) < 0
+		    || (byte != 0xa3 && byte != 0x25))
+			continue;
+
+		/* Skip immediate argument in the instruction.  */
+		offset += 4;
+
+		if (elf_read_next_u8(lte->plt_data, &offset, &byte) < 0
+		    || byte != 0x68
+		    || elf_read_next_u32(lte->plt_data,
+					 &offset, &reloc_arg) < 0)
+			continue;
+
+		if (lte->ehdr.e_machine == EM_386) {
+			if (reloc_arg % 8 != 0)
+				continue;
+			reloc_arg /= 8;
+		}
+
+		*VECT_ELEMENT(&lte->arch.plt_map, unsigned int, reloc_arg) = i;
+	}
+
+	return 0;
+}
+
+void
+arch_elf_destroy(struct ltelf *lte)
+{
+	VECT_DESTROY(&lte->arch.plt_map, uint32_t, NULL, NULL);
+}
-- 
2.40.1

